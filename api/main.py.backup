"""
FastAPI Backend for Multi-Agent Learning Ecosystem
===================================================

Production-ready API with:
- 6 specialized MCP systems (35 agents)
- Authentication & Authorization (JWT + API keys)
- Rate Limiting (Redis-backed)
- Vector Memory (FAISS + PostgreSQL)
- Event Bus (Redis Streams)
- Plugin System (Dynamic loading)
- SkillForge (Auto-discovery)
- Prometheus Monitoring
"""

from fastapi import FastAPI, HTTPException, Query, Depends
from fastapi.middleware.cors import CORSMiddleware
from typing import List, Optional
from datetime import datetime, date
import os
import sys
import logging

from database import get_db
from database_async import create_pool, close_pool, check_database_health
from models import (
    LearningSource, LearningReflection,
    AgentSkill,
    LearningSourceCreate, LearningMaterialResponse,
    AgentProfileResponse, WorkflowResponse
)
from services import (
    get_learning_sources, get_learning_materials, get_material_by_id,
    get_reflections, get_workflows, get_agent_profiles, get_agent_skills,
    create_learning_source, trigger_workflow
)

# Import MCP routes
from mcp_routes import router as mcp_router

# Import authentication routes
sys.path.insert(0, os.path.dirname(__file__))
from auth_routes import router as auth_router

# Import rate limiting
from rate_limiter import RateLimiter, RateLimitMiddleware

# Import security middleware
from security_middleware import configure_security_headers

# Import monitoring
sys.path.insert(0, os.path.join(os.path.dirname(__file__), ".."))
from monitoring import PrometheusMiddleware, metrics_endpoint, METRICS_ENABLED

# Import plugin manager
from plugins.plugin_manager import PluginManager

# Import structured logging
from structured_logger import setup_logging, RequestLoggingMiddleware

# Setup structured logging
setup_logging()
logger = logging.getLogger("MainAPI")

# =============================================================================
# APPLICATION INITIALIZATION
# =============================================================================

app = FastAPI(
    title="Multi-Agent Learning Ecosystem API + MCP Systems v2.0",
    description="""
    Production-Grade Unified API for Multi-Agent Learning & 6 MCP Systems

    **Features:**
    - üîê JWT Authentication & API Key Support
    - üö¶ Rate Limiting (Redis-backed)
    - üìä Prometheus Monitoring
    - üß† Hybrid Vector Memory (FAISS + PostgreSQL)
    - üîå Dynamic Plugin System
    - ü§ñ SkillForge Auto-Discovery
    - üì° Redis Event Bus

    **MCP Systems (35 agents):**
    - FinPsyMCP (9 agents) - Financial analysis
    - PydiniRedEnterprise (8 agents) - Workflow automation
    - LexMCP (4 agents) - Legal compliance
    - InnoMCP (5 agents) - Innovation management
    - CreativeMCP (4 agents) - Content generation
    - EduMCP (5 agents) - Adaptive education
    """,
    version="2.0.0",
    docs_url="/docs",
    redoc_url="/redoc"
)

# =============================================================================
# MIDDLEWARE CONFIGURATION
# =============================================================================

# 1. CORS Configuration
origins = os.getenv("CORS_ORIGINS", "http://localhost:3000,http://localhost:8000").split(",")
app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# 2. Request Logging & Tracing
app.add_middleware(RequestLoggingMiddleware)
logger.info("‚úÖ Request logging and tracing enabled")

# 3. Security Headers (OWASP protection)
security_enabled = os.getenv("SECURITY_HEADERS_ENABLED", "true").lower() == "true"
if security_enabled:
    configure_security_headers(app)
    logger.info("‚úÖ Security headers enabled (HSTS, CSP, X-Frame-Options, etc.)")

# 4. Prometheus Monitoring (if enabled)
if METRICS_ENABLED:
    app.add_middleware(PrometheusMiddleware)
    logger.info("‚úÖ Prometheus monitoring enabled")

# 5. Rate Limiting
rate_limiter = RateLimiter()
app.add_middleware(RateLimitMiddleware, rate_limiter=rate_limiter)
logger.info("‚úÖ Rate limiting enabled")

# =============================================================================
# ROUTER INCLUSION
# =============================================================================

# Include MCP router
app.include_router(mcp_router)
logger.info("‚úÖ MCP router included (6 systems, 35 agents)")

# Include authentication router
app.include_router(auth_router)
logger.info("‚úÖ Authentication router included")

# =============================================================================
# STARTUP & SHUTDOWN EVENTS
# =============================================================================

@app.on_event("startup")
async def startup_event():
    """Initialize services on startup"""
    logger.info("üöÄ Starting Multi-Agent Learning Ecosystem API v2.0")

    # Initialize async database connection pool
    try:
        await create_pool()
        health = await check_database_health()
        logger.info(f"‚úÖ Database pool initialized: {health}")
    except Exception as e:
        logger.error(f"‚ùå Database pool initialization failed: {e}")
        raise  # Critical failure - cannot start without database

    # Initialize plugin manager
    try:
        plugin_manager = PluginManager(
            plugin_dir="./plugins",
            auto_load=True
        )
        app.state.plugin_manager = plugin_manager
        plugins = plugin_manager.list_plugins()
        logger.info(f"‚úÖ Plugin manager initialized: {len(plugins)} plugins loaded")
    except Exception as e:
        logger.warning(f"‚ö†Ô∏è  Plugin manager initialization failed: {e}")

    # Connect to Redis for rate limiting
    try:
        await rate_limiter.connect()
        logger.info("‚úÖ Redis connection established for rate limiting")
    except Exception as e:
        logger.warning(f"‚ö†Ô∏è  Redis connection failed: {e}")

    # Initialize event bus (if available)
    try:
        from mcp_agents.event_bus import RedisEventBus
        event_bus = RedisEventBus()
        await event_bus.connect()
        app.state.event_bus = event_bus
        logger.info("‚úÖ Redis Event Bus initialized")
    except Exception as e:
        logger.warning(f"‚ö†Ô∏è  Event Bus initialization failed: {e}")

    # Initialize hybrid memory (if available)
    try:
        from mcp_agents.hybrid_memory import HybridVectorMemory
        hybrid_memory = HybridVectorMemory(
            use_faiss=True,
            use_postgres=True
        )
        app.state.hybrid_memory = hybrid_memory
        stats = hybrid_memory.get_stats()
        logger.info(f"‚úÖ Hybrid Vector Memory initialized: {stats}")
    except Exception as e:
        logger.warning(f"‚ö†Ô∏è  Hybrid Memory initialization failed: {e}")

    logger.info("üéâ All systems initialized and ready!")


@app.on_event("shutdown")
async def shutdown_event():
    """Cleanup on shutdown"""
    logger.info("üõë Shutting down Multi-Agent Learning Ecosystem API")

    # Close database connection pool
    try:
        await close_pool()
        logger.info("‚úÖ Database pool closed")
    except Exception as e:
        logger.error(f"‚ùå Error closing database pool: {e}")

    # Close Redis connections
    try:
        await rate_limiter.close()
        logger.info("‚úÖ Rate limiter connections closed")
    except Exception as e:
        logger.error(f"‚ùå Error closing rate limiter: {e}")

    # Close event bus
    if hasattr(app.state, "event_bus"):
        try:
            await app.state.event_bus.close()
            logger.info("‚úÖ Event bus connections closed")
        except Exception as e:
            logger.error(f"‚ùå Error closing event bus: {e}")

    logger.info("üëã Shutdown complete")

# =============================================================================
# MONITORING ENDPOINTS
# =============================================================================

@app.get("/metrics")
async def prometheus_metrics():
    """Prometheus metrics endpoint"""
    return metrics_endpoint()

# ============================================================================
# HEALTH CHECK
# ============================================================================

@app.get("/health")
async def health_check():
    """
    Comprehensive health check endpoint

    Returns service status and health of all components
    """
    # Check database health
    db_health = await check_database_health()

    # Overall status
    overall_status = "healthy" if db_health.get("status") == "healthy" else "degraded"

    return {
        "status": overall_status,
        "timestamp": datetime.now().isoformat(),
        "service": "multi-agent-learning-api",
        "version": "2.0.0",
        "components": {
            "database": db_health,
            "api": {"status": "healthy"}
        }
    }

# ============================================================================
# LEARNING SOURCES & MATERIALS
# ============================================================================

@app.get("/api/sources", response_model=List[dict])
async def list_learning_sources(
    status: Optional[str] = None,
    source_type: Optional[str] = None,
    limit: int = Query(50, ge=1, le=500),
    offset: int = Query(0, ge=0),
    db=Depends(get_db)
):
    """Get list of learning sources with optional filters"""
    try:
        sources = get_learning_sources(db, status, source_type, limit, offset)
        return sources
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/sources", status_code=201)
async def create_source(
    source: LearningSourceCreate,
    db=Depends(get_db)
):
    """Create a new learning source"""
    try:
        result = create_learning_source(db, source)
        return result
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/materials", response_model=List[LearningMaterialResponse])
async def list_learning_materials(
    processed: Optional[bool] = None,
    limit: int = Query(50, ge=1, le=500),
    offset: int = Query(0, ge=0),
    db=Depends(get_db)
):
    """Get list of learning materials"""
    try:
        materials = get_learning_materials(db, processed, limit, offset)
        return materials
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/materials/{material_id}", response_model=LearningMaterialResponse)
async def get_material(material_id: str, db=Depends(get_db)):
    """Get a specific learning material by ID"""
    try:
        material = get_material_by_id(db, material_id)
        if not material:
            raise HTTPException(status_code=404, detail="Material not found")
        return material
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/materials/{material_id}/similar")
async def find_similar_materials(
    material_id: str,
    limit: int = Query(10, ge=1, le=50),
    db=Depends(get_db)
):
    """Find similar materials using vector similarity search"""
    try:
        cursor = db.cursor()

        # Get the vector of the target material
        cursor.execute(
            "SELECT vector FROM learning_materials WHERE id = %s AND vector IS NOT NULL",
            (material_id,)
        )
        result = cursor.fetchone()

        if not result or not result[0]:
            raise HTTPException(status_code=404, detail="Material not found or has no embedding")

        # Find similar materials using cosine similarity
        cursor.execute("""
            SELECT
                id, title, description,
                1 - (vector <=> %s::vector) as similarity_score
            FROM learning_materials
            WHERE id != %s AND vector IS NOT NULL
            ORDER BY vector <=> %s::vector
            LIMIT %s
        """, (result[0], material_id, result[0], limit))

        similar = cursor.fetchall()
        cursor.close()

        return [
            {
                "id": str(row[0]),
                "title": row[1],
                "description": row[2],
                "similarity_score": float(row[3])
            }
            for row in similar
        ]
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

# ============================================================================
# REFLECTIONS
# ============================================================================

@app.get("/api/reflections", response_model=List[dict])
async def list_reflections(
    agent_id: Optional[str] = None,
    material_id: Optional[str] = None,
    limit: int = Query(50, ge=1, le=500),
    offset: int = Query(0, ge=0),
    db=Depends(get_db)
):
    """Get list of learning reflections"""
    try:
        reflections = get_reflections(db, agent_id, material_id, limit, offset)
        return reflections
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

# ============================================================================
# AGENTS
# ============================================================================

@app.get("/api/agents", response_model=List[AgentProfileResponse])
async def list_agents(
    agent_type: Optional[str] = None,
    status: Optional[str] = None,
    db=Depends(get_db)
):
    """Get list of agent profiles"""
    try:
        agents = get_agent_profiles(db, agent_type, status)
        return agents
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/agents/{agent_id}/skills", response_model=List[dict])
async def list_agent_skills(
    agent_id: str,
    db=Depends(get_db)
):
    """Get skills for a specific agent"""
    try:
        skills = get_agent_skills(db, agent_id)
        return skills
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/agent_skills", response_model=List[dict])
async def list_all_agent_skills(
    db=Depends(get_db)
):
    """Get all agent skills across all agents"""
    try:
        cursor = db.cursor()
        cursor.execute("""
            SELECT
                ags.id, ags.agent_id, ags.skill_name,
                ags.skill_category, ags.skill_level, ags.proficiency,
                ags.practice_count, ags.last_practiced
            FROM agent_skills ags
            ORDER BY ags.skill_level DESC
            LIMIT 100
        """)

        skills = cursor.fetchall()
        cursor.close()

        return [
            {
                "id": str(row[0]),
                "agent_id": row[1],
                "skill_name": row[2],
                "skill_category": row[3],
                "skill_level": float(row[4]) if row[4] else 0.0,
                "proficiency": row[5],
                "practice_count": row[6],
                "last_practiced": row[7].isoformat() if row[7] else None
            }
            for row in skills
        ]
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/agents/performance")
async def get_agent_performance(db=Depends(get_db)):
    """Get agent performance overview from materialized view"""
    try:
        cursor = db.cursor()
        cursor.execute("""
            SELECT
                agent_id, agent_name, agent_type, status,
                performance_score, total_tasks_completed, success_rate,
                skill_count, avg_skill_level, materials_studied, reflections_created
            FROM agent_performance_overview
            ORDER BY performance_score DESC
        """)

        performance = cursor.fetchall()
        cursor.close()

        return [
            {
                "agent_id": row[0],
                "agent_name": row[1],
                "agent_type": row[2],
                "status": row[3],
                "performance_score": float(row[4]) if row[4] else 0.0,
                "total_tasks_completed": row[5],
                "success_rate": float(row[6]) if row[6] else 0.0,
                "skill_count": row[7],
                "avg_skill_level": float(row[8]) if row[8] else 0.0,
                "materials_studied": row[9],
                "reflections_created": row[10]
            }
            for row in performance
        ]
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

# ============================================================================
# WORKFLOWS
# ============================================================================

@app.get("/api/workflows", response_model=List[WorkflowResponse])
async def list_workflows(
    workflow_name: Optional[str] = None,
    status: Optional[str] = None,
    limit: int = Query(50, ge=1, le=500),
    db=Depends(get_db)
):
    """Get list of workflow executions"""
    try:
        workflows = get_workflows(db, workflow_name, status, limit)
        return workflows
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/workflows/trigger")
async def trigger_learning_workflow(
    workflow_name: str = "daily_recursive_learning_full",
    db=Depends(get_db)
):
    """Trigger a Prefect workflow execution"""
    try:
        result = await trigger_workflow(workflow_name)
        return result
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/workflows/status")
async def get_workflow_status(db=Depends(get_db)):
    """Get workflow status summary"""
    try:
        cursor = db.cursor()
        cursor.execute("""
            SELECT
                workflow_name, total_runs, successful_runs, failed_runs,
                avg_duration_seconds, last_run_time
            FROM workflow_status_summary
            ORDER BY last_run_time DESC
        """)

        status = cursor.fetchall()
        cursor.close()

        return [
            {
                "workflow_name": row[0],
                "total_runs": row[1],
                "successful_runs": row[2],
                "failed_runs": row[3],
                "avg_duration_seconds": float(row[4]) if row[4] else 0.0,
                "last_run_time": row[5].isoformat() if row[5] else None
            }
            for row in status
        ]
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

# ============================================================================
# ANALYTICS & STATS
# ============================================================================

@app.get("/api/stats/overview")
async def get_system_overview(db=Depends(get_db)):
    """Get system-wide statistics"""
    try:
        cursor = db.cursor()

        stats = {}

        # Total counts
        cursor.execute("SELECT COUNT(*) FROM learning_sources")
        stats['total_sources'] = cursor.fetchone()[0]

        cursor.execute("SELECT COUNT(*) FROM learning_materials")
        stats['total_materials'] = cursor.fetchone()[0]

        cursor.execute("SELECT COUNT(*) FROM learning_materials WHERE processed = true")
        stats['processed_materials'] = cursor.fetchone()[0]

        cursor.execute("SELECT COUNT(*) FROM learning_reflections")
        stats['total_reflections'] = cursor.fetchone()[0]

        cursor.execute("SELECT COUNT(*) FROM agent_profile WHERE status = 'active'")
        stats['active_agents'] = cursor.fetchone()[0]

        cursor.execute("SELECT COUNT(*) FROM workflow_metrics WHERE status = 'completed'")
        stats['completed_workflows'] = cursor.fetchone()[0]

        # Averages
        cursor.execute("SELECT AVG(quality_score) FROM learning_materials WHERE quality_score > 0")
        result = cursor.fetchone()
        stats['avg_material_quality'] = float(result[0]) if result[0] else 0.0

        cursor.execute("SELECT AVG(performance_score) FROM agent_profile")
        result = cursor.fetchone()
        stats['avg_agent_performance'] = float(result[0]) if result[0] else 0.0

        cursor.close()

        return stats
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/stats/daily/{agent_id}")
async def get_daily_stats(
    agent_id: str,
    start_date: Optional[date] = None,
    end_date: Optional[date] = None,
    db=Depends(get_db)
):
    """Get daily statistics for a specific agent"""
    try:
        cursor = db.cursor()

        query = """
            SELECT
                summary_date, materials_processed, reflections_created,
                skills_improved, total_learning_time_seconds,
                key_learnings, challenges_faced
            FROM daily_agent_summary
            WHERE agent_id = %s
        """

        params = [agent_id]

        if start_date:
            query += " AND summary_date >= %s"
            params.append(start_date)

        if end_date:
            query += " AND summary_date <= %s"
            params.append(end_date)

        query += " ORDER BY summary_date DESC LIMIT 30"

        cursor.execute(query, params)
        results = cursor.fetchall()
        cursor.close()

        return [
            {
                "date": row[0].isoformat(),
                "materials_processed": row[1],
                "reflections_created": row[2],
                "skills_improved": row[3],
                "learning_time_hours": row[4] / 3600 if row[4] else 0,
                "key_learnings": row[5],
                "challenges_faced": row[6]
            }
            for row in results
        ]
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
